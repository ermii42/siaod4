#include <iostream>
#include "binaryTree.h"
#include "windows.h"

using namespace std;

// 8 9 11 15 19 20 21 7 3 2 1 5 6 4 13 14 10 12 17 16 18

/*
Вид дерева: идеально сбалансированное из n узлов (не AVL).
1. Реализовать операции общие для вариантов c 1 по 7
1) Создать идеально сбалансированное бинарное дерево из n узлов.
Структура узла дерева включает: информационная часть узла, указатель
на левое и указатель на правое поддерево. Информационная часть узла
определена вариантом.
2) Отобразить дерево на экране, повернув его справа налево.
2. Реализовать операции варианта.
3. Разработать программу, демонстрирующую выполнение всех операций
на ваших тестах и тестах преподавателя.
4. Оформить отчет.
 */

/*
6 Целое число
Используя рекурсивный алгоритм определить
количество уровней в дереве.
Вернуть узел с максимальным значением, обходя
дерево в ширину.
Определить максимальное и минимальное
значения.
 */
int main() {
    TREE A;
    int n;
    SetConsoleOutputCP(CP_UTF8);
    cout << "Введите количество вершин -...\n";
    cin >> n;
    cout << "Вводите ключи...\n";
    A.Tree(n, A.GetDuk());
    A.Vyvod(A.GetDuk(), 0);
    cout << endl << A.getDept(A.GetDuk());
    node* nd;
    nd = A.maxNode(A.GetDuk());
    cout<<endl<<nd->Key;
}
